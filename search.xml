<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode 869 - 重新排序得到2的幂]]></title>
    <url>%2F2018%2F07%2F19%2Fleetcode%2Fleetcode-869%2F</url>
    <content type="text"><![CDATA[leetcode 869 - 重新排序得到 2 的幂从正整数 N 开始，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。 如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。 示例 1： 12输入：1输出：true 示例 2： 12输入：10输出：false 示例 3： 12输入：16输出：true 示例 4： 12输入：24输出：false 示例 5： 12输入：46输出：true 提示： 1 &lt;= N &lt;= 10^9 解法这里有两个要求：全排列+如何判断一个数是2的幂 判断是2的幂1. 计算1的个数若是2的幂，该数二进制格式下应该只有一个1，且题目提示1&lt;=N&lt;=10^9，所以N在二进制表示下，最大有30位 因此：判断N在二进制表示下在30位以内是否只有一个1 1234567891011public static boolean isPowerOf2(int N) &#123; int b = 0; for (int i = 0; i &lt; 30; i++) &#123; int is1 = N &amp; 1; N = N &gt;&gt; 1; if (is1 == 1) &#123; b++; &#125; &#125; return b == 1;&#125; 2. N和N-1按位与得0则为2的幂我们知道2的幂是只有一个1，那么当N-1之后，低位的0需要向高位借1，若出现在第n个高位为1时，借位停止，此时，N-1的第n位至第0位与N的刚好相反，而第n+1位到最高位在N是2的幂的情况下都为0，则N&amp;N-1得0，但是若不是2的幂，即n+1位到最高位中存在1那么N&amp;N-1不得0 123public static boolean isPowerOf2(int N) &#123; return N&amp;N-1==0;&#125; 3.重要 通用于：m的最大次幂Mod N得0则N为m的幂2的最大次幂Mod N 得0则N为2的幂 123public static boolean isPowerOf2(int N) &#123; return N&gt;0?1073741824%N==0:false;&#125; 全排列递归实现全排列： 设R(A1,A2,A3,…,An)表示为A1,A2,…,A3的全排列，相当于要得到A1,R(A2,A3,…,An)、A2,R(A1,A3,…,An)、…、An,R(A1,A2,…An-1)，我们要相当于第index(此时为0)个元素与第index+i(i∈[0,n-index-1])位元素的情况下,index+1到n-1全排列情况 12345678910111213141516171819202122232425262728293031323334 private static void permutation(int[] values, int index, int num,List&lt;Integer&gt; result) &#123; int i = 0; if (num == 0) &#123; //递归边界：当排列长度为0 int p = 1; int sum = 0; for (int f = 0; f &lt; values.length; f++) &#123; sum += values[f]*p; p = p*10; &#125; if (sum&gt;=p/10) &#123; //去除前导数字为0的数字 result.add(sum); &#125; return; &#125; // 递归逻辑： 1.交换第index和第index+i个数字 // index是获取部分排列之外的最大个元素的位置：即A1,A2,R(A3,...,An)的index为1 // 2. 获取第index不变，index+1改变的全排列:（eg:index为1）A1,A2,Ax,(A3,...,An) // 3. 交换第index和第index+i个数字 for (i = 0; i &lt; num; i++) &#123; swap(values, index + i, index); permutation(values, index + 1, num - 1,result); swap(values, index, index + i); &#125; return; &#125; private static void swap(int[] values, int i, int j) &#123; int tmp = values[i]; values[i] = values[j]; values[j] = tmp; &#125;&#125; 实现：1234567891011121314151617181920public static boolean reorderedPowerOf2(int N) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); while (N != 0) &#123; list.add(N % 10); N = N / 10; &#125; int[] a = new int[list.size()]; int j = 0; for (Integer i : list) &#123; a[j++] = i; &#125; List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); permutation(a, 0, a.length, a.length,result); for (Integer i:result) &#123; if(i==1||(i&amp;(i-1))==0) return true; &#125; return false;&#125; 思考换个角度想还有另一种思路。我们前面想的是获取全排列，然后逐个判断是不是2的幂；反过来，我们可以获取是2的幂的所有数，然后来判断N的数字是否能拼接成这些数的。这一个要求两个点：1)获取2的幂的所有数/获取N的位数的数m，然后获取m位的2的幂的所有数. 2)如何拼接匹配 这个思路的话，比较主要的是第二个点，如何拼接匹配，应该将数字转换为存储在一个容器内，之后遍历1)获得的所有的数做：从容器中获取数字以匹配2的幂的数Tm ，若最后完全匹配，且容器内的元素全部用完(当第一点中获取的N经过位数判断则这两个条件前者满足后者一定也满足) 这个思路的过程稍微复杂，一气呵成地写下来应该需要花点时间，我之后有时间再写一下实现，感受一下emmm]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 870 - 优势洗牌]]></title>
    <url>%2F2018%2F07%2F19%2Fleetcode%2Fleetcode-870%2F</url>
    <content type="text"><![CDATA[leetcode 870 - 优势洗牌给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。 返回 A 的任意排列，使其相对于 B 的优势最大化。 示例 1： 12输入：A = [2,7,11,15], B = [1,10,4,11]输出：[2,11,7,15] 示例 2： 12输入：A = [12,24,8,32], B = [13,25,32,11]输出：[24,32,8,12] 提示： 1 &lt;= A.length = B.length &lt;= 10000 0 &lt;= A[i] &lt;= 10^9 0 &lt;= B[i] &lt;= 10^9 解法思路优势洗牌，不得不让我们想起 田忌赛马。其中的原理，我是这么理解的，既然A要打胜仗，可以 先把A排序，得到一个升序的序； 遍历B 对B[i]进行操作：从A[0]开始遍历A找到第一个比B[i]大的A[j]之后将A[j]赋给res[i]以满足res[i]&gt;B[i]，找到A[j]之后即可立刻跳出A遍历循环； 给不满足A[i]&gt;B[i]的情况赋值： 阶段2可确定 满足A[i]&gt;B[i]的那些元素的情况，但是 这还不够，我们需要将那些败局也赋上，即那些A[i]&lt;=B[i]的情况，那么我们总不能分不清A中哪些元素已被使用了吧？所以我们可以在执行2的时候对已经赋值了res[i]的下标进行记录：resIsSetted[i]=1（初始化的时候是0）,对已经使用了的A[j]的下标进行记录：AiIsAssigned[j]=1（初始化的时候是0） 这个时候 我们再遍历一次 B 对哪些未做优势对比（resIsSetted[i]==0）的res[i]进行设置值：遍历A得到第一个未被分配（AiIsAssigned[j]==0）的A[j]赋值给res[i]，之后:resIsSetted[i]=1;AiIsAssigned[j]=1; 之后立刻跳出A遍历循环 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.study;import java.util.Arrays;/** * @Author: jerx * @Description: * @Date: Created in 16:12 2018/7/19 * @Modified By: */public class AdvantageCount &#123; public static int[] advantageCount(int[] A, int[] B) &#123; int[] AiIsAssigned = new int[A.length]; int[] resIsSetted = new int[A.length]; int[] res = new int[A.length]; Arrays.sort(A); for (int i = 0; i &lt; B.length; i++) &#123; for (int j = 0; j &lt; A.length; j++) &#123; if (A[j] &gt; B[i] &amp;&amp; AiIsAssigned[j] == 0 &amp;&amp; resIsSetted[i] == 0) &#123; // a[j]为第一个比B[i]大的且未被分配，置于res[i] res[i] = A[j]; AiIsAssigned[j] = 1; resIsSetted[i] = 1; break; &#125; &#125; &#125; for (int i=0;i&lt;B.length;i++) &#123; if (resIsSetted[i] == 0) &#123; for (int k = 0; k &lt; A.length; k++) &#123; if (AiIsAssigned[k]==0)&#123; res[i] = A[k]; AiIsAssigned[k] = 1; resIsSetted[i] = 1; break; &#125; &#125; &#125; &#125; return res; &#125; // 测试 public static void main(String[] args) &#123; System.out.println(Arrays.toString(advantageCount(new int[]&#123;2, 0, 4, 1, 2&#125;, new int[]&#123;1, 3, 0, 0, 2&#125;))); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode 868 - 二进制间距]]></title>
    <url>%2F2018%2F07%2F19%2Fleetcode%2Fleetcode-868%2F</url>
    <content type="text"><![CDATA[868. 二进制间距给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 如果没有两个连续的 1，返回 0 。 示例 1： 12345678输入：22输出：2解释：22 的二进制是 0b10110 。在 22 的二进制表示中，有三个 1，组成两对连续的 1 。第一对连续的 1 中，两个 1 之间的距离为 2 。第二对连续的 1 中，两个 1 之间的距离为 1 。答案取两个距离之中最大的，也就是 2 。 示例 2： 1234输入：5输出：2解释：5 的二进制是 0b101 。 示例 3： 1234输入：6输出：1解释：6 的二进制是 0b110 。 示例 4： 12345输入：8输出：0解释：8 的二进制是 0b1000 。在 8 的二进制表示中没有连续的 1，所以返回 0 。 提示： 1 &lt;= N &lt;= 10^9 实现思路N最大为10^9 ,所以2的最大次幂为2^30那么在这30位中我们要计算二进制间距最长的，应该是 一次次遍历找到连续的1记录下连续的1之间的差(i-pre)，若差大于之前计算过的连续1之差len，则将i-pre赋值给len以获得最大的len，遍历下去就可以得到最大的len了~ 1234567891011121314151617181920212223242526272829303132package com.study;/** * @Author: jerx * @Description: * @Date: Created in 20:23 2018/7/18 * @Modified By: */public class BinaryGap &#123; public static int binaryGap(int N) &#123; int b; int len = 0; int pre = -1; for (int i = 0; i &lt; 30; i++) &#123; b = N &amp; 1; System.out.print(b); N = N &gt;&gt; 1; if (b == 1) &#123; if (pre!=-1) &#123; len = i - pre &gt; len ? i - pre : len; &#125; pre = i; &#125; &#125; return len; &#125; public static void main(String[] args) &#123; System.out.println(binaryGap(8)); &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F07%2F16%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[动态代理1. 代理是什么代理者 受委托者 的委托 而向外提供接口 优点： 隐藏委托者的实现 可以实现客户与委托者间的解耦。在不修改委托者代码的情况下能够做一些额外的处理 2. 静态代理what？何为静态？ 代理者在程序运行前就已经定义好了：Java代码中定义好了代理类 在通常情况下，代理类和委托类，会实现同一接口/派生自相同的父类。 how？round-01接下来 我们用Bank类代表银行，BankAgent类代表中介代理，以此简单介绍静态代理的简单实现：委托类 和代理类都实现了Loan接口，Loan接口定义如下： 123456789101112package com.study.proxy.staticProxy;/** * @Author: jerx * @Description: * @Date: Created in 15:23 2018/7/16 * @Modified By: */public interface Loan &#123; void loan(User user); void ad();&#125; 而Bank委托类定义如下： 12345678910111213141516171819package com.study.proxy.staticProxy;/** * @Author: jerx * @Description: * @Date: Created in 15:29 2018/7/16 * @Modified By: */public class Bank implements Loan&#123; public void loan(User user) &#123; System.out.println(user.getName()+"银行贷款"); &#125; public void ad() &#123; System.out.println("贷款业务广告"); &#125;&#125; 而BankAgent代理类定义如下： 12345678910111213141516171819package com.study.proxy.staticProxy;/** * @Author: jerx * @Description: * @Date: Created in 15:30 2018/7/16 * @Modified By: */public class BankAgent implements Loan &#123; private Bank bank = new Bank(); public void loan(User user) &#123; bank.loan(user); &#125; public void ad() &#123; bank.ad(); &#125;&#125; 由代理类我们现在知道静态代理可以通过聚合来实现。只要让代理类持有委托类的引用即可 round-02现在又新需求，给银行增加一个过滤：现在只给征信超过1000的成年人。 那么通过静态代理，我们不需要更改Bank类的代码，只需要在BankAgent类中的Loan方法添加一个判断就ok了，如下： 1234567891011121314151617181920package com.study.proxy.staticProxy;/** * @Author: jerx * @Description: * @Date: Created in 15:30 2018/7/16 * @Modified By: */public class BankAgent implements Loan &#123; private Bank bank = new Bank(); public void loan(User user) &#123; if (user.getCreditInvestigation() &gt; 1000 &amp;&amp; user.getAge() &gt;= 18) &#123; bank.loan(user); &#125; &#125; public void ad() &#123; bank.ad(); &#125;&#125; 这就对应了我们之前说的：实现了客户与委托类的解耦，在不修改委托类代码的情况下能够做一些额外的处理。静态代理的局限在于运行前必须编写好代理类。那么接下来要介绍动态代理来满足我们的愿景 3. 动态代理what？代理类在程序运行时创建的代理方式被成为 动态代理，在运行时根据我们在Java代码中的”指示”动态生成的。 优点：对比静态代理，可以很方便的对代理类的函数进行统一的处理，而不需要修改每个代理类的函数。这么说比较抽象，下面我们结合一个实例来介绍动态代理的优势如何体现。 how -1：jdk动态代理现在有一个需求：在执行委托类的方法之前输出before，在执行完毕后输出after。 若是采用静态代理实现我们的需求需要我们在每个方法中都添加相应的逻辑： 1234567891011121314151617181920212223242526package com.study.proxy.dynamicProxy;import com.study.proxy.staticProxy.Bank;import com.study.proxy.staticProxy.Loan;import com.study.proxy.staticProxy.User;/** * @Author: jerx * @Description: * @Date: Created in 15:21 2018/7/16 * @Modified By: */public class DynamicBankAgent implements Loan &#123; private Bank bank = new Bank(); public void loan(User user) &#123; System.out.println("before"); bank.loan(user); System.out.println("after"); &#125; public void ad() &#123; System.out.println("before"); bank.ad(); System.out.println("after"); &#125;&#125; 但是如果 说我们这样对每个方法都取修改的话 那会变得非常冗余，这个时候我们可以通过动态代理，做一个”统一的指示”，从而对所有代理类的方法进行统一处理，而不用逐一修改每个方法，如下： (1) 调用处理器接口 (jdk的一个接口)12345package java.lang.reflect;public interface InvocationHandler &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;&#125; (2) 委托类同之前的Bank (3) 中介类（调用处理器）1234567891011121314151617181920212223242526package com.study.proxy.dynamicProxy;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @Author: jerx * @Description: * @Date: Created in 16:51 2018/7/16 * @Modified By: */public class DynamicProxy implements InvocationHandler &#123; private Object object; // object 委托类对象 public DynamicProxy(Object object) &#123; this.object = object; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException &#123; System.out.println("before"); Object result = method.invoke(object, args); System.out.println("after"); return result; &#125;&#125; (4) 场景类newProxyInstance我们调用Proxy类的newProxyInstance以获取代理类实例，该代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器中。 1234public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException 这个方法的loader是定义了代理类的ClassLoader；interfaces是代理类实现的接口列表；h是调用处理器，也就是我们实现了InvocationHandler接口的类实例DynamicProxy 场景类12345678910111213141516171819202122232425262728293031323334package com.study.proxy.dynamicProxy;import com.study.proxy.staticProxy.Bank;import com.study.proxy.staticProxy.BankAgent;import com.study.proxy.staticProxy.Loan;import com.study.proxy.staticProxy.User;import java.lang.reflect.Proxy;/** * @Author: jerx * @Description: * @Date: Created in 17:02 2018/7/16 * @Modified By: */public class Main &#123; public static void main(String[] args) &#123; Bank bank = new Bank(); // 1. 创建中介类实例 DynamicProxy inter = new DynamicProxy(bank); // 2. 设置saveGeneratedFiles值为true表示：要生成class字节码文件方便分析 System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true"); // 3. 获取代理类实例Loan Loan loan = (Loan)(Proxy.newProxyInstance(Loan.class.getClassLoader(),new Class[]&#123;Loan.class&#125;,inter)); System.out.println("$Proxy0.class全名: "+Proxy.getProxyClass(Loan.class.getClassLoader(), Loan.class)); User user = new User(); user.setAge(18); user.setCreditInvestigation(1001); user.setName("your name"); // 4. 通过代理类对象调用代理类方法，实际上会转到invoke方法调用 loan.loan(user); loan.ad(); &#125;&#125; 生成的代理类的class文件反编译得到的java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package com.sun.proxy;import com.study.proxy.staticProxy.Loan;import com.study.proxy.staticProxy.User;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Loan &#123; private static Method m1; private static Method m4; private static Method m2;to private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final void loan(User var1) throws &#123; try &#123; super.h.invoke(this, m4, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void ad() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m4 = Class.forName("com.study.proxy.staticProxy.Loan").getMethod("loan", Class.forName("com.study.proxy.staticProxy.User")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m3 = Class.forName("com.study.proxy.staticProxy.Loan").getMethod("ad"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; how -2：cglib动态代理(1) 拦截器接口 (cglib的一个接口)1234567package net.sf.cglib.proxy;import java.lang.reflect.Method;public interface MethodInterceptor extends Callback &#123; Object intercept(Object var1, Method var2, Object[] var3, MethodProxy var4) throws Throwable;&#125; (2) 委托类 (没有接口)12345678910111213141516package com.study.proxy.cglibProxy;/** * @Author: jerx * @Description: * @Date: Created in 10:38 2018/7/17 * @Modified By: */public class BankWithoutInterface &#123; public void loan() &#123; System.out.println("贷款"); &#125; public void ad() &#123; System.out.println("广告"); &#125;&#125; (3) 拦截器 (实现拦截器接口的实现类)12345678910111213141516171819202122232425package com.study.proxy.cglibProxy;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * @Author: jerx * @Description: * @Date: Created in 10:42 2018/7/17 * @Modified By: */public class CgLibProxy implements MethodInterceptor &#123; public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; if (method.getName().equals("loan")) &#123; System.out.println("贷款成功"); &#125; System.out.println("beforrrre"); Object result = methodProxy.invokeSuper(o,objects); System.out.println("afterrrrr"); return result; &#125;&#125; (4) 代理类的工厂类 123456789101112131415161718package com.study.proxy.cglibProxy;import net.sf.cglib.proxy.Enhancer;/** * @Author: jerx * @Description: * @Date: Created in 10:47 2018/7/17 * @Modified By: */public class ProxyFactory &#123; public static Object getGcLibDynProxy(Object target)&#123; Enhancer enhancer=new Enhancer(); enhancer.setSuperclass(target.getClass()); enhancer.setCallback(new CgLibProxy()); return enhancer.create(); &#125;&#125; (4) 场景类123456789101112131415package com.study.proxy.cglibProxy;/** * @Author: jerx * @Description: * @Date: Created in 10:49 2018/7/17 * @Modified By: */public class Main &#123; public static void main(String[] args) &#123; BankWithoutInterface bank = (BankWithoutInterface)ProxyFactory.getGcLibDynProxy(new BankWithoutInterface()); bank.loan(); bank.ad(); &#125;&#125; 4. 动态代理底层机制jdk动态代理newProxyInstance1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@CallerSensitivepublic static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; // 不允许传入的调用处理器h为空，使用的是Objects里面的一个方法 Objects.requireNonNull(h); // 克隆 传入的接口类数组 final Class&lt;?&gt;[] intfs = interfaces.clone(); // 获取系统的安全管理类 final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; // 安全检查 checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * 生成代理类的核心代码 * &lt;p&gt; * 该方法重要：如何获取代理类？ */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; // 若代理类的构造方法不是public的，需要将其Accessible设置为true if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; // 调用构造方法，并将调用处理器传入 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException|InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125;&#125; getProxyClass01234567891011//生成一个代理类，在调用该方法前，必须调用checkProxyAccess校验权限 private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; //代理接口数限制 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; //如果由给定的加载器实现给定的接口定义的代理类存在，返回缓存;否则，它将通过ProxyClassFactory创建代理类 return proxyClassCache.get(loader, interfaces); &#125; cglib动态代理]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之6大设计原则]]></title>
    <url>%2F2018%2F07%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[6大设计原则单一职责原则 :SRP定义单一职责 指的是：应该有且仅有一个原因引起类的变更 典例 RBAC通过分配和取消角色来实现用户权限的授予和取消，使动作主体（用户）和资源的行为（权限）分离 举个例子： 12345public interface IPhone &#123; public void dial(String phoneNumber); public void chat(Object o); public void hangup();&#125; 以上包括两个职责：协议管理和数据传送。这两个职责实际上互不影响，因此我们可以根据单一职责原则，来拆分他们，如下； 12345678public interface IConnectionManager &#123; public void dial(String phoneNumber); public void hangup();&#125;public interface IDataTransfer &#123; public void chat(Object o);&#125; 这样做的好处： 类的复杂性降低，实现的职责有清晰的定义 由复杂性降低导致可读性提高 由可读性提高导致可维护性提高 变更引起的风险降低，若做好单一职责，则一个接口修改只对相应的实现类影响，对其他接口不影响，提高系统扩展性和维护性 重要难处：单一职责最难划分的是职责，职责如何细化，这需要从实际的项目去考虑，若从功能上来说，定义一个IPhone接口是没有错的，实现了电话的功能。 本质： 其实 职责相当于导致变化的变化原因，单一职责原则提出了用职责/变化原因来衡量接口设计是否优良，但是职责和变化原因是不可度量的，因项目、环境而异。 里氏替换原则:LSP定义： 对于每个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，P的行为没有发生变化，则S类型是T类型的子类型。 所有引用基类的地方必须透明地适用其子类的对象 4层含义： 子类必须完全实现父类的方法(父类出现的地方，子类可以替代) 子类可以有自己的个性(子类出现的地方，父类可以替代) 覆盖或实现父类的方法时输入参数可以被放大(说白了子类方法重载父类方法的时候输入范围可以随便来) 1234567891011121314151617181920212223242526272829303132package com.study.LSP;import java.util.HashMap;import java.util.Map;/** * @Author: jerx * @Description: * @Date: Created in 12:07 2018/7/9 * @Modified By: */public class Client &#123; public static void main(String[] args) &#123; invokerF(); &#125; private static void invokerF() &#123; Father f = new Father(); HashMap map = new HashMap(); f.doSomething(map); &#125; //上面的方法，根据里氏替换原则，父类出现的地方子类可以完全替换 private static void invoker() &#123; Son f = new Son(); HashMap map = new HashMap(); f.doSomething(map); //由此可见，子类既可以重写父类的方法，又可以重载父类的方法以此扩大输入参数的范围 ， Map map1 = new HashMap(); f.doSomething(map1); &#125;&#125; 覆写或实现父类的方法时输出结果可以被缩小（说白了子类方法重写父类方法/子类方法重载父类方法的时候输出结果可以随便来） 重要实践要点在项目中若要采用里氏替换原则，尽量避免子类的”个性“： 一旦子类有个性，这个子类与父类关系难以调和，把子类作为父类使用，则抹杀了子类的个性 把子类单独作为一个业务来使用，则会让代码间的耦合关系混乱，缺乏类替换的标准 依赖倒置原则:DIP三层含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象。 在java语言中的表现： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过 接口或抽象类产生的； 接口或抽象类不依赖于实现类； 实现类依赖接口或抽象类。 依赖的三种写法：1.构造函数传递依赖对象接口类： 123456789101112package com.study.DIP;/** * @Author: jerx * @Description: * @Date: Created in 15:16 2018/7/9 * @Modified By: * 构造函数传递依赖对象 */public interface IDriver &#123; void drive();&#125; 实现类： 1234567891011121314151617181920212223package com.study.DIP.impl;import com.study.DIP.ICar;import com.study.DIP.IDriver;/** * @Author: jerx * @Description: * @Date: Created in 15:19 2018/7/9 * @Modified By: */public class DriverWiredFromConstructor implements IDriver &#123; private ICar car; public DriverWiredFromConstructor(ICar car) &#123; this.car = car; &#125; //由构造函数注入依赖对象Car public void drive() &#123; System.out.println("司机驾驶汽车:"); this.car.run(); &#125;&#125; 2.Setter方法传递依赖对象接口类： 123456789101112package com.study.DIP;/** * @Author: jerx * @Description: * @Date: Created in 15:23 2018/7/9 * @Modified By: */public interface IDriverSetter extends IDriver&#123; void setCar(ICar car);&#125; 实现类： 1234567891011121314151617181920212223package com.study.DIP.impl;import com.study.DIP.ICar;import com.study.DIP.IDriverSetter;/** * @Author: jerx * @Description: * @Date: Created in 15:21 2018/7/9 * @Modified By: */public class DriverWiredFromSetter implements IDriverSetter&#123; private ICar car; public void drive() &#123; System.out.println("司机驾驶汽车"); car.run(); &#125; //由setter方法传递依赖对象Car public void setCar(ICar car) &#123; this.car = car; &#125;&#125; 3.接口声明依赖对象接口类： 1234567891011package com.study.DIP;/** * @Author: jerx * @Description: * @Date: Created in 15:27 2018/7/9 * @Modified By: */public interface IDriverInterface &#123; void drive(ICar car);&#125; 实现类： 123456789101112131415161718package com.study.DIP.impl;import com.study.DIP.ICar;import com.study.DIP.IDriverInterface;/** * @Author: jerx * @Description: * @Date: Created in 15:27 2018/7/9 * @Modified By: */public class DriverWiredFromInterface implements IDriverInterface&#123; //由接口声明依赖对象Car public void drive(ICar car) &#123; System.out.println("司机驾驶汽车"); car.run(); &#125;&#125; 重要实践要点 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备 这是依赖倒置的基本要求，有了抽象才能倒置 变量的表面类型尽量是接口或者是抽象类 任何类都不应该从具体类派生 尽量不要覆写基类的方法 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。 结合里氏替换原则使用 接口负责定义public属性和方法，并且声明与其他对象的依赖关系， 抽象类负责公共构造部分的实现， 实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。 重要什么是依赖倒置想知道什么是依赖倒置，应该先了解一下依赖正置是什么。 依赖正置说白了就是类间的依赖是实实在在的实现类间的依赖，这是面向实现编程 而编写程序需要抽象事物，抽象的结果是产生接口类和抽象类，而倒置则是指我们根据系统的设计而产生的抽象间的依赖，以代替人们传统思维中的事物间的依赖。 接口隔离原则（高内聚）定义建立单一接口，不要建立臃肿庞大的接口。 区别于单一职责原则接口隔离原则与单一职责的审视角度是不相同的， 单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分， 而接口隔离原则要求接口的方法尽量少 保证接口的纯洁性 尽量小尽量小，但是当根据接口单一原则要拆分接口时，必须先满足单一职责原则 高内聚不讲任何条件、立刻完成任务的行为就是高内聚的表现，高内聚就是提高接口、类、模块的处理能力，减少对外的交互。 高内聚要求在接口中尽量少公布public方法 定制服务​ 有限度 实践要点 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑压缩接口中的public方法 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理； 迪米特原则:LKP（低耦合）一个对象应该对其他对象有最少的了解。 4层含义1. 只和朋友交流出现在成员变量、方法的输入输出参数中的类称为成员朋友类； 而出现在方法体内部的类不属于朋友类 这一层含义希望的是，类应该只跟成员变量、方法的输入输出参数中的类交流，所谓交流又是什么意思呢？ 2. 朋友间也是有距离的尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。 这一层的含义希望的是，类尽量不要堆外公布太多public方法，尽量内敛。 3. 是自己的就是自己的经常出现的情况：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 这一层的含义希望的是：属于类自身的东西没必要独立出来，当一个方法放在本类中既不增加类间关系又不对本类产生负面影响，则该方法就应该属于该类，该方法放置于本类中是合理的。 4. 谨慎使用Serializable这一层的含义希望的是：每一个类都应该谨慎使用Serializable 实践要点类间解耦，弱耦合 开闭原则一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 是什么由定义可知开闭原则就是 一个软件实体应该对扩展开放，对修改关闭。那么什么是软件实体呢，软件实体包括项目中按一定逻辑规则划分的模块、抽象和类、方法。这些对象对扩展开放的意思是允许扩展，而尽量不要做覆盖性的修改，什么算覆盖性的修改呢，做个假设，本来你有个实现类实现了对书籍价格的获取，而后需求改变需要对书籍打折后的价格的获取，那么若对之前的获取价格的方法修改实现，改为获取打折后的价格，将原本约定好的接口意义做了修改，使得之前的意义下的该接口无法使用，这就相当于覆盖性的修改。当然了，覆盖性这个是我自己提出的说法，只是为了帮助理解。 注意：开闭原则表示软件实体对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。 为什么其实想知道为什么要这么做，也就是得要明白这么做的好处/重要性了。关于开闭原则，可以通过以下几个反面去了解他的重要性： 1.对测试：只需测试新增的类及其方法，不需要重复测试之前的方法单元测试是对类的测试，如果不遵守开闭原则而去修改一个方法/多个方法代码来完成变化，那么该类的测试方法无疑需要重构，这当然非常浪费人力，而遵守开闭原则则只需对扩展的类及其方法添加新的测试方法即可，不需要重构之前的测试方法。 2. 开闭原则可以提高复用性避免相同逻辑散落在不同方法中，逻辑粒度越小，复用率越高 3. 开闭原则可以提高可维护性4. 面向对象开发的要求怎么实现1.抽象约束第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法； 第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类； 第三，抽象层尽量保持稳定，一旦确定即不允许修改。 2.元数据（metadata）控制模块行为什么是元数据？ 元数据用于描述环境和数据的数据，就是配置参数，可以从文件中/数据库中获得。 达到极致的控制反转，使用最多的是Spring容器 3. 制定项目章程项目章程指定了所有人员都必须遵守的约定，对于项目来说，约定优于配置。我们可以通过制定项目的约定规则来实现开闭原则 4. 封装变化第一，将相同的变化封装到一个接口或抽象类中； 第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中 实践要点类必须做到高内聚低耦合，否则类文件的替换会引起不可预料的故障；项目约定规章比较重要的，应该约定好合适的章程；应该提前预测变化，设计架构的同时应该要考虑适应可能发生的变化。 总结：说白了单一职责原则要求类根据单一的职责划分，但是职责的细化根据项目、环境而异，他告诉我一个类如何划分定义出来；接口隔离原则要求类的定义尽量高内聚，所谓高内聚，；而迪米特原则，要求类之间的关系尽量地低耦合，所谓低耦合，即要求类只与成员变量、方法输入输出参数交流，同时类对外公布的public方法应该尽量地少；]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java演进之门]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0%2Fnetty%2FJavaIO%E6%BC%94%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[1.1 I/O基础入门Java1.4之前的早期版本，Java 对I/O的支持不完善，存在以下挑战和困难: 无缓冲加快速度：没有数据缓冲区，I/O性能存在问题； 无通道概念：没有C/C++中的Channel概念，只有输入和输出流； 阻塞时间长：同步阻塞式I/O通信(BIO)，通常会导致通信线程被长时间阻塞； 支持的字符集有限，硬件可移植性不好 1.1.1 Linux网络I/O模型简介Linux的内核 将所有外部设备看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor, fd) 而对一个socket的读写也会有响应的描述符，称为]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket编程]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0%2Fnetty%2FSocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Socket编程Unix输入输出操作范本:Open—–&gt; Read—-&gt;Write—&gt;close Java 的 Socket 编程客户端编写123456789101112131415161718192021222324/*代码1.1 */public class ClientSocket &#123; public static void main(String args[]) &#123; //通信标识符：网络地址+端口 String host = "127.0.0.1"; int port = 8919; try &#123; //Open : 通过通信标识符 来创建socket对象 Socket client = new Socket(host, port); //Write : 1.通过socket对象得到OutputStream对象 Writer writer = new OutputStreamWriter(client.getOutputStream()); // 2.写入数据 writer.write("Hello From Client"); // 3.刷新(将缓冲区的数据发送出去) writer.flush(); //Close : 关闭 OutputStream和Socket writer.close(); client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端编写Open—&gt;Read—&gt;Close 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*代码2.1*/package com.study.SocketPrograming;import java.io.IOException;import java.io.InputStreamReader;import java.io.Reader;import java.net.ServerSocket;import java.net.Socket;/** * @Author: jerx * @Description: * @Date: Created in 14:20 2018/4/15 * @Modified By: */public class Server &#123; public static void main(String[] args) &#123; int port = 8080; // 1.Open: 开启socket对象 ServerSocket server; try &#123; server = new ServerSocket(port); // 2.监听并 获取客户端的请求socket // accept是一个阻塞方法，在服务器与客户端之间建立联系之前一直阻塞 Socket socket = server.accept(); Reader reader = new InputStreamReader(socket.getInputStream()); char[] chars = new char[1024]; int len; // 3.Read: // 不断执行: // ①调用reader.read(char[])将1024个字符的数据copy进缓冲区中 // ②缓冲区中的数据再添加进StringBuilder对象 // 直到数据完全copy完毕 StringBuilder builder = new StringBuilder(); while ((len =reader.read(chars))!=-1)&#123; builder.append(new String(chars, 0, len)); &#125; System.out.println("Receive from client message=: " + builder); //4.Close reader.close(); socket.close(); server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1. Socket对象的创建基本需求：创建当前服务端开启的Socket监听端口 设置为8080，等待其他进程向我们这个端口发送信息 2.阻塞等待与客户端的连接 accept方法是阻塞方法，返回值是指向客户端socket对象的一个引用 阻塞于何处？ 可以打开accept源码查看一番 12345678910/*代码2.2*/public Socket accept() throws IOException &#123; if (isClosed()) throw new SocketException("Socket is closed"); if (!isBound()) throw new SocketException("Socket is not bound yet"); Socket s = new Socket((SocketImpl) null); implAccept(s); return s;&#125; implAccept方法 向implAccept方法传入一个SocketImpl为null的Socket，我们知道 Socket的实现都是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的，一个没有SocketImpl的Socket无法工作 那么我们继续看implAccept的方法 1234567891011121314151617181920212223242526272829303132333435/*代码2.3*/protected final void implAccept(Socket s) throws IOException &#123; SocketImpl si = null; try &#123; if (s.impl == null) //设置SocketImpl s.setImpl(); else &#123; s.impl.reset(); &#125; si = s.impl; s.impl = null; si.address = new InetAddress(); si.fd = new FileDescriptor(); getImpl().accept(si); SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccept(si.getInetAddress().getHostAddress(), si.getPort()); &#125; &#125; catch (IOException e) &#123; if (si != null) si.reset(); s.impl = si; throw e; &#125; catch (SecurityException e) &#123; if (si != null) si.reset(); s.impl = si; throw e; &#125; s.impl = si; s.postAccept(); &#125; 这里最重要的是getImpl.accept()方法的调用，在调用前，给Socket si创建了一个ServerSocketImpl， 但仍然没有指定该Socket的端口和网络地址，那么继续看getImpl().accept()方法。 getImpl.accept() 123456789101112131415/*代码2.4*/protected synchronized void accept(SocketImpl s) throws IOException &#123; if (s instanceof PlainSocketImpl) &#123; // pass in the real impl not the wrapper. //这里要将实际的Impl类传入accept方法，而不是包装类 SocketImpl delegate = ((PlainSocketImpl)s).impl; delegate.address = new InetAddress(); delegate.fd = new FileDescriptor(); impl.accept(delegate); // set fd to delegate's fd to be compatible with older releases s.fd = delegate.fd; &#125; else &#123; impl.accept(s); &#125; &#125; 判断是不是PlainSocketImpl，这个类在官方文档中介绍为 ，默认的sokcet实现类，源码中希望将一个真正的SocketImpl对象传入，而非其包装对象，可见PlainSocketImpl应该是一个SocketImpl的包装类。 所以我们将一个真正的SocketImpl对象传入impl.accept()方法中，且看impl.accept()方法 impl.accept() 1234567891011121314/*代码2.5*//** * Accepts connections. * @param s the connection */protected void accept(SocketImpl s) throws IOException &#123; //获取文件描述符, acquireFD(); try &#123; socketAccept(s); &#125; finally &#123; releaseFD(); &#125;&#125; 在这个方法中 为SocketImpl对象的 fduseCount加1 socketAccept(s); 12345678910111213141516171819202122232425262728293031/*代码2.6*/void socketAccept(SocketImpl s) throws IOException &#123; int nativefd = checkAndReturnNativeFD(); if (s == null) throw new NullPointerException("socket is null"); int newfd = -1; InetSocketAddress[] isaa = new InetSocketAddress[1]; if (timeout &lt;= 0) &#123; newfd = accept0(nativefd, isaa); &#125; else &#123; configureBlocking(nativefd, false); try &#123; waitForNewConnection(nativefd, timeout); newfd = accept0(nativefd, isaa); if (newfd != -1) &#123; configureBlocking(newfd, true); &#125; &#125; finally &#123; configureBlocking(nativefd, true); &#125; &#125; /* Update (SocketImpl)s' fd */ fdAccess.set(s.fd, newfd); /* Update socketImpls remote port, address and localport */ InetSocketAddress isa = isaa[0]; s.port = isa.getPort(); s.address = isa.getAddress(); s.localport = localport;&#125; 我们debug到 accept0()方法，发现是一个native方法，是一个非Java代码的接口，在native方法中阻塞等待得到新文件描述符以及通信标识符(网络地址+端口) 当我们启动一个Client时，accept0立刻返回新文件描述符，得到通信标识符 之后： 设置文件描述符，和网络地址及端口 回到上一层方法栈impl.accept， fdUseCount减1 回到上一层方法栈getImpl.accept()，设置文件描述符 回到上一层方法栈implAccept(),在应用有自己的安全管理器的情况下，检查接收的客户端连接的访问权限，而后将Socket的SocketImpl设置为含有该连接信息(文件描述符、通信标识符等)的SocketImpl，并将Socket的连接标志，创建标志，绑定标志设为true 回到上一层方法栈accept() 方法，接收连接后，将含有该连接信息的Socket返回 小结这里的阻塞等待 的 是关于客户端连接的信息(文件描述符，通信标识符等) 3.得到输入流，然后使用缓冲读取得到信息详解看代码2.1 4.关闭IO对象资源释放 文件描述符文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F04%2F05%2FJVM%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略1.职能： 垃圾收集器的职能就是将堆中的”已死去“的对象进行回收。 那么在对堆进行回收前，必须先判断对象是否还活着 如果由于代码设计不合理可能会导致一些无用的对象仍然被判定为存活着而导致内存泄漏 2.对象死活 2.1.引用计数 优点：效率高，实现简单 缺点：很难解决对象之间相互循环引用的问题(这也是虚拟机不选用该算法来管理内存的原因) http://blog.csdn.net/u013613428/article/details/53763925 123456789101112131415161718192021222324252627282930313233/** * VM args : * -XX:+PrintGC 输出GC日志 * -XX:+PrintGCDetails 输出GC的详细日志 * -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） * -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） * -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 * -Xloggc:../logs/gc.log 日志文件的输出路径 * @Author: jerx * @Description: * @Date: Created in 15:08 2018/2/2 * @Modified By: */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB=1024*1024; private byte[] bigSize = new byte[2*_1MB]; public static void testGC()&#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; System.gc(); &#125; public static void main(String[] args) throws InterruptedException &#123; ReferenceCountingGC.testGC(); Thread.sleep(1000*10); &#125;&#125; 运行结果： 123 [GC 6718K-&gt;4848K(123392K), 0.0020877 secs][Full GC 4848K-&gt;4619K(123392K), 0.0112221 secs]Process finished with exit code 0 2.2.可达性分析 GC Roots : 虚拟机栈的本地变量表 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象从GC Roots出发向下搜索，所走过的路径：引用链当一个对象到GC Roots 没有任何引用链相连，即从GC Roots到该对象不可达，则为不可用对象，可回收。2.3.细分引用以上两种判断对象是否存活的算法都与引用有关。原来Java中对reference类型的定义：一个存储了一个代表另外一块内存地址的数值，在这样的定义下，一个对象只有被引用或者没有被引用的状态；实际上还需要描述一些特殊的对象：当内存空间足够时，能保留在内存中，而若内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。在jdk1.2之后，Java扩充了引用的概念：四种引用: 强引用 ：Object obj = new Object();软引用 ：SoftReference 在系统将要发生内存溢出异常去之前会把这些对象列进垃圾回收范围内弱引用 ：WeakReference 被弱引用关联的对象只能生存到下一次垃圾收集发生前，当垃圾收集器工作时，一定会回收掉只被弱引用关联的对象虚引用 : PhantomReference 对象不会因为弱引用的存在而对自身生存时间构成影响，设置虚引用的唯一目的是为了能在这个对象被收集器回收时收到一个系统通知 2.4.死前挣扎上面是解决了如何知道对象是否需要存活接下来来解决何时将对象回收 发现对象A没有与GC Roots相连接的引用链—&gt;第一次标记，并且进行一次筛选，筛选条件：是否需要执行finalize方法 有必要则将对象A放在F-Queue队列中，并在一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它， 执行指的是触发该方法的执行，但不会承诺等待它运行结束。 只触发finalize方法而不承诺等待它运行结束的原因：若对象A在finalize方法中执行缓慢/出现死循环，这会导致F-Queue队列其他对象永久等待，甚至整个系统崩溃。 怎么才算有必要执行？对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过 GC将对F-Queue中的对象进行第二次规模的标记，如果finalize方法中对象A成功拯救了自己(只需要重新与引用链的任何一个对象建立关联)，那么第二次标记时对象A将被移出”即将回收“的集合 分析：finalize方法运行代价高昂、不确定性大，不能保证各个对象的调用顺序，关闭外部资源之类的工作应该使用try-finally 2.5.回收方法区2.5.1.回收内容： 废弃常量 无用的类2.5.2.回收废弃常量条件： 没有任何String对象2.5.3.可能回收类的条件 实例已全部被回收 该类的加载器已被回收 该类对应的Class对象没有再任何地方被引用3.垃圾收集算法 3.1.标记-清除算法简述： 标记 标记所有需要回收的对象清除 直接清除标记过的对象 不足： 效率低 标记和清除 效率都不高 (怎么不高法？)空间碎片 标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致在程序运行过程中要分配较大对象时无法找到足够的连续内存而不得不触发又一次垃圾收集动作 3.2.复制算法简述： 划分为两块大小相等的两块，每次只用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存中，在回收时就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效 不足： 代价是将内存缩为原来一半 变形： 现在商用虚拟机包括HotSpot，会将内存分为一块Eden空间、两块较小的Survivor空间，HotSpot中Eden:fromSurvivor:toSurvivor=8:1:1分配担保：回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor，这块Survivor不够用时，依赖其他内存进行分配担保：即当这块Survivor没有足够空间存放上一次新生代收集下来的存活对象，则这些对象将直接通过分配担保进入老年代。 3.3.标记-整理算法此算法主要适用于老年代先标记然后将所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 3.4.分代收集算法新生代用复制算法老年代用标记-清除/标记-整理算法进行回收 4.算法实现4.1.枚举根节点 GC Roots准确式GC： 准确GC，准确的意思就是：虚拟机能确切知道哪些地方存放对象引用，从而加快GCRoots枚举的效率 执行系统停顿下来时，不需要一个不漏地检查完所有执行上下文和全局的引用位置 虚拟机有方法直接得知哪些地方存放着对象引用： HotSpot使用一组称为 OopMap 的数据结构达到这个目的，它将对象内什么偏移量上是什么类型的数据计算出来，在 JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。 eg:以下例子 call 指令有 OopMap 记录，指明 ebx 寄存器、栈中偏移量为 16 的内存区域中各有一个普通对象指针，有效范围从 call 指令开始直到 0x026eb730 (指令流的起始位置) + 14212345678910111213[Verified Entry Point]0x026eb730: mov %eax,-0x8000(%esp)…………;; ImplicitNullCheckStub slow case0x026eb7a9: call 0x026e83e0 ; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;;*caload; - java.lang.String::hashCode@48 (line 1489); &#123;runtime_call&#125;0x026eb7ae: push $0x83c5c18 ; &#123;external_word&#125;0x026eb7b3: call 0x026eb7b80x026eb7b8: pusha0x026eb7b9: call 0x0822bec0 ; &#123;runtime_call&#125;0x026eb7be: hlt 安全点为什么要有安全点的概念？ 因为 安全点 问题： 考虑如何让 GC发生时让所有线程都“跑”到最近的安全点上再停顿下来？两种方案： 抢先式中断(现在没有虚拟机使用这种方法) 先中断 再检查各个线程是否在安全点上，否则恢复线程，让其执行到安全点上 主动式中断 各线程执行到 在安全点时/在创建对象需要分配内存时 主动轮询 中断标志 中断标志为真时就自己中断挂起 ​ 安全区域 ​]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
