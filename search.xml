<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java演进之门]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0%2Fnetty%2FJavaIO%E6%BC%94%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[1.1 I/O基础入门Java1.4之前的早期版本，Java 对I/O的支持不完善，存在以下挑战和困难: 无缓冲加快速度：没有数据缓冲区，I/O性能存在问题； 无通道概念：没有C/C++中的Channel概念，只有输入和输出流； 阻塞时间长：同步阻塞式I/O通信(BIO)，通常会导致通信线程被长时间阻塞； 支持的字符集有限，硬件可移植性不好 1.1.1 Linux网络I/O模型简介Linux的内核 将所有外部设备看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor, fd) 而对一个socket的读写也会有响应的描述符，称为]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket编程]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0%2Fnetty%2FSocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Socket编程Unix输入输出操作范本:Open—–&gt; Read—-&gt;Write—&gt;close Java 的 Socket 编程客户端编写123456789101112131415161718192021222324/*代码1.1 */public class ClientSocket &#123; public static void main(String args[]) &#123; //通信标识符：网络地址+端口 String host = "127.0.0.1"; int port = 8919; try &#123; //Open : 通过通信标识符 来创建socket对象 Socket client = new Socket(host, port); //Write : 1.通过socket对象得到OutputStream对象 Writer writer = new OutputStreamWriter(client.getOutputStream()); // 2.写入数据 writer.write("Hello From Client"); // 3.刷新(将缓冲区的数据发送出去) writer.flush(); //Close : 关闭 OutputStream和Socket writer.close(); client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端编写Open—&gt;Read—&gt;Close 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*代码2.1*/package com.study.SocketPrograming;import java.io.IOException;import java.io.InputStreamReader;import java.io.Reader;import java.net.ServerSocket;import java.net.Socket;/** * @Author: jerx * @Description: * @Date: Created in 14:20 2018/4/15 * @Modified By: */public class Server &#123; public static void main(String[] args) &#123; int port = 8080; // 1.Open: 开启socket对象 ServerSocket server; try &#123; server = new ServerSocket(port); // 2.监听并 获取客户端的请求socket // accept是一个阻塞方法，在服务器与客户端之间建立联系之前一直阻塞 Socket socket = server.accept(); Reader reader = new InputStreamReader(socket.getInputStream()); char[] chars = new char[1024]; int len; // 3.Read: // 不断执行: // ①调用reader.read(char[])将1024个字符的数据copy进缓冲区中 // ②缓冲区中的数据再添加进StringBuilder对象 // 直到数据完全copy完毕 StringBuilder builder = new StringBuilder(); while ((len =reader.read(chars))!=-1)&#123; builder.append(new String(chars, 0, len)); &#125; System.out.println("Receive from client message=: " + builder); //4.Close reader.close(); socket.close(); server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1. Socket对象的创建基本需求：创建当前服务端开启的Socket监听端口 设置为8080，等待其他进程向我们这个端口发送信息 2.阻塞等待与客户端的连接 accept方法是阻塞方法，返回值是指向客户端socket对象的一个引用 阻塞于何处？ 可以打开accept源码查看一番 12345678910/*代码2.2*/public Socket accept() throws IOException &#123; if (isClosed()) throw new SocketException("Socket is closed"); if (!isBound()) throw new SocketException("Socket is not bound yet"); Socket s = new Socket((SocketImpl) null); implAccept(s); return s;&#125; implAccept方法 向implAccept方法传入一个SocketImpl为null的Socket，我们知道 Socket的实现都是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的，一个没有SocketImpl的Socket无法工作 那么我们继续看implAccept的方法 1234567891011121314151617181920212223242526272829303132333435/*代码2.3*/protected final void implAccept(Socket s) throws IOException &#123; SocketImpl si = null; try &#123; if (s.impl == null) //设置SocketImpl s.setImpl(); else &#123; s.impl.reset(); &#125; si = s.impl; s.impl = null; si.address = new InetAddress(); si.fd = new FileDescriptor(); getImpl().accept(si); SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccept(si.getInetAddress().getHostAddress(), si.getPort()); &#125; &#125; catch (IOException e) &#123; if (si != null) si.reset(); s.impl = si; throw e; &#125; catch (SecurityException e) &#123; if (si != null) si.reset(); s.impl = si; throw e; &#125; s.impl = si; s.postAccept(); &#125; 这里最重要的是getImpl.accept()方法的调用，在调用前，给Socket si创建了一个ServerSocketImpl， 但仍然没有指定该Socket的端口和网络地址，那么继续看getImpl().accept()方法。 getImpl.accept() 123456789101112131415/*代码2.4*/protected synchronized void accept(SocketImpl s) throws IOException &#123; if (s instanceof PlainSocketImpl) &#123; // pass in the real impl not the wrapper. //这里要将实际的Impl类传入accept方法，而不是包装类 SocketImpl delegate = ((PlainSocketImpl)s).impl; delegate.address = new InetAddress(); delegate.fd = new FileDescriptor(); impl.accept(delegate); // set fd to delegate's fd to be compatible with older releases s.fd = delegate.fd; &#125; else &#123; impl.accept(s); &#125; &#125; 判断是不是PlainSocketImpl，这个类在官方文档中介绍为 ，默认的sokcet实现类，源码中希望将一个真正的SocketImpl对象传入，而非其包装对象，可见PlainSocketImpl应该是一个SocketImpl的包装类。 所以我们将一个真正的SocketImpl对象传入impl.accept()方法中，且看impl.accept()方法 impl.accept() 1234567891011121314/*代码2.5*//** * Accepts connections. * @param s the connection */protected void accept(SocketImpl s) throws IOException &#123; //获取文件描述符, acquireFD(); try &#123; socketAccept(s); &#125; finally &#123; releaseFD(); &#125;&#125; 在这个方法中 为SocketImpl对象的 fduseCount加1 socketAccept(s); 12345678910111213141516171819202122232425262728293031/*代码2.6*/void socketAccept(SocketImpl s) throws IOException &#123; int nativefd = checkAndReturnNativeFD(); if (s == null) throw new NullPointerException("socket is null"); int newfd = -1; InetSocketAddress[] isaa = new InetSocketAddress[1]; if (timeout &lt;= 0) &#123; newfd = accept0(nativefd, isaa); &#125; else &#123; configureBlocking(nativefd, false); try &#123; waitForNewConnection(nativefd, timeout); newfd = accept0(nativefd, isaa); if (newfd != -1) &#123; configureBlocking(newfd, true); &#125; &#125; finally &#123; configureBlocking(nativefd, true); &#125; &#125; /* Update (SocketImpl)s' fd */ fdAccess.set(s.fd, newfd); /* Update socketImpls remote port, address and localport */ InetSocketAddress isa = isaa[0]; s.port = isa.getPort(); s.address = isa.getAddress(); s.localport = localport;&#125; 我们debug到 accept0()方法，发现是一个native方法，是一个非Java代码的接口，在native方法中阻塞等待得到新文件描述符以及通信标识符(网络地址+端口) 当我们启动一个Client时，accept0立刻返回新文件描述符，得到通信标识符 之后： 设置文件描述符，和网络地址及端口 回到上一层方法栈impl.accept， fdUseCount减1 回到上一层方法栈getImpl.accept()，设置文件描述符 回到上一层方法栈implAccept(),在应用有自己的安全管理器的情况下，检查接收的客户端连接的访问权限，而后将Socket的SocketImpl设置为含有该连接信息(文件描述符、通信标识符等)的SocketImpl，并将Socket的连接标志，创建标志，绑定标志设为true 回到上一层方法栈accept() 方法，接收连接后，将含有该连接信息的Socket返回 小结这里的阻塞等待 的 是关于客户端连接的信息(文件描述符，通信标识符等) 3.得到输入流，然后使用缓冲读取得到信息详解看代码2.1 4.关闭IO对象资源释放 文件描述符文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F04%2F05%2FJVM%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略1.职能： 垃圾收集器的职能就是将堆中的”已死去“的对象进行回收。 那么在对堆进行回收前，必须先判断对象是否还活着 如果由于代码设计不合理可能会导致一些无用的对象仍然被判定为存活着而导致内存泄漏 2.对象死活 2.1.引用计数 优点：效率高，实现简单 缺点：很难解决对象之间相互循环引用的问题(这也是虚拟机不选用该算法来管理内存的原因) http://blog.csdn.net/u013613428/article/details/53763925 123456789101112131415161718192021222324252627282930313233/** * VM args : * -XX:+PrintGC 输出GC日志 * -XX:+PrintGCDetails 输出GC的详细日志 * -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） * -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） * -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 * -Xloggc:../logs/gc.log 日志文件的输出路径 * @Author: jerx * @Description: * @Date: Created in 15:08 2018/2/2 * @Modified By: */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB=1024*1024; private byte[] bigSize = new byte[2*_1MB]; public static void testGC()&#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; System.gc(); &#125; public static void main(String[] args) throws InterruptedException &#123; ReferenceCountingGC.testGC(); Thread.sleep(1000*10); &#125;&#125; 运行结果： 123 [GC 6718K-&gt;4848K(123392K), 0.0020877 secs][Full GC 4848K-&gt;4619K(123392K), 0.0112221 secs]Process finished with exit code 0 2.2.可达性分析 GC Roots : 虚拟机栈的本地变量表 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象从GC Roots出发向下搜索，所走过的路径：引用链当一个对象到GC Roots 没有任何引用链相连，即从GC Roots到该对象不可达，则为不可用对象，可回收。2.3.细分引用以上两种判断对象是否存活的算法都与引用有关。原来Java中对reference类型的定义：一个存储了一个代表另外一块内存地址的数值，在这样的定义下，一个对象只有被引用或者没有被引用的状态；实际上还需要描述一些特殊的对象：当内存空间足够时，能保留在内存中，而若内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。在jdk1.2之后，Java扩充了引用的概念：四种引用: 强引用 ：Object obj = new Object();软引用 ：SoftReference 在系统将要发生内存溢出异常去之前会把这些对象列进垃圾回收范围内弱引用 ：WeakReference 被弱引用关联的对象只能生存到下一次垃圾收集发生前，当垃圾收集器工作时，一定会回收掉只被弱引用关联的对象虚引用 : PhantomReference 对象不会因为弱引用的存在而对自身生存时间构成影响，设置虚引用的唯一目的是为了能在这个对象被收集器回收时收到一个系统通知 2.4.死前挣扎上面是解决了如何知道对象是否需要存活接下来来解决何时将对象回收 发现对象A没有与GC Roots相连接的引用链—&gt;第一次标记，并且进行一次筛选，筛选条件：是否需要执行finalize方法 有必要则将对象A放在F-Queue队列中，并在一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它， 执行指的是触发该方法的执行，但不会承诺等待它运行结束。 只触发finalize方法而不承诺等待它运行结束的原因：若对象A在finalize方法中执行缓慢/出现死循环，这会导致F-Queue队列其他对象永久等待，甚至整个系统崩溃。 怎么才算有必要执行？对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过 GC将对F-Queue中的对象进行第二次规模的标记，如果finalize方法中对象A成功拯救了自己(只需要重新与引用链的任何一个对象建立关联)，那么第二次标记时对象A将被移出”即将回收“的集合 分析：finalize方法运行代价高昂、不确定性大，不能保证各个对象的调用顺序，关闭外部资源之类的工作应该使用try-finally 2.5.回收方法区2.5.1.回收内容： 废弃常量 无用的类2.5.2.回收废弃常量条件： 没有任何String对象2.5.3.可能回收类的条件 实例已全部被回收 该类的加载器已被回收 该类对应的Class对象没有再任何地方被引用3.垃圾收集算法 3.1.标记-清除算法简述： 标记 标记所有需要回收的对象清除 直接清除标记过的对象 不足： 效率低 标记和清除 效率都不高 (怎么不高法？)空间碎片 标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致在程序运行过程中要分配较大对象时无法找到足够的连续内存而不得不触发又一次垃圾收集动作 3.2.复制算法简述： 划分为两块大小相等的两块，每次只用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存中，在回收时就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效 不足： 代价是将内存缩为原来一半 变形： 现在商用虚拟机包括HotSpot，会将内存分为一块Eden空间、两块较小的Survivor空间，HotSpot中Eden:fromSurvivor:toSurvivor=8:1:1分配担保：回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor，这块Survivor不够用时，依赖其他内存进行分配担保：即当这块Survivor没有足够空间存放上一次新生代收集下来的存活对象，则这些对象将直接通过分配担保进入老年代。 3.3.标记-整理算法此算法主要适用于老年代先标记然后将所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 3.4.分代收集算法新生代用复制算法老年代用标记-清除/标记-整理算法进行回收 4.算法实现4.1.枚举根节点 GC Roots准确式GC： 准确GC，准确的意思就是：虚拟机能确切知道哪些地方存放对象引用，从而加快GCRoots枚举的效率 执行系统停顿下来时，不需要一个不漏地检查完所有执行上下文和全局的引用位置 虚拟机有方法直接得知哪些地方存放着对象引用： HotSpot使用一组称为 OopMap 的数据结构达到这个目的，它将对象内什么偏移量上是什么类型的数据计算出来，在 JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。 eg:以下例子 call 指令有 OopMap 记录，指明 ebx 寄存器、栈中偏移量为 16 的内存区域中各有一个普通对象指针，有效范围从 call 指令开始直到 0x026eb730 (指令流的起始位置) + 14212345678910111213[Verified Entry Point]0x026eb730: mov %eax,-0x8000(%esp)…………;; ImplicitNullCheckStub slow case0x026eb7a9: call 0x026e83e0 ; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;;*caload; - java.lang.String::hashCode@48 (line 1489); &#123;runtime_call&#125;0x026eb7ae: push $0x83c5c18 ; &#123;external_word&#125;0x026eb7b3: call 0x026eb7b80x026eb7b8: pusha0x026eb7b9: call 0x0822bec0 ; &#123;runtime_call&#125;0x026eb7be: hlt 安全点为什么要有安全点的概念？ 因为 安全点 问题： 考虑如何让 GC发生时让所有线程都“跑”到最近的安全点上再停顿下来？两种方案： 抢先式中断(现在没有虚拟机使用这种方法) 先中断 再检查各个线程是否在安全点上，否则恢复线程，让其执行到安全点上 主动式中断 各线程执行到 在安全点时/在创建对象需要分配内存时 主动轮询 中断标志 中断标志为真时就自己中断挂起 ​ 安全区域 ​]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
