<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式之6大设计原则]]></title>
    <url>%2F2018%2F07%2F10%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[6大设计原则单一职责原则 :SRP定义单一职责 指的是：应该有且仅有一个原因引起类的变更 典例 RBAC通过分配和取消角色来实现用户权限的授予和取消，使动作主体（用户）和资源的行为（权限）分离 举个例子： 12345public interface IPhone &#123; public void dial(String phoneNumber); public void chat(Object o); public void hangup();&#125; 以上包括两个职责：协议管理和数据传送。这两个职责实际上互不影响，因此我们可以根据单一职责原则，来拆分他们，如下； 12345678public interface IConnectionManager &#123; public void dial(String phoneNumber); public void hangup();&#125;public interface IDataTransfer &#123; public void chat(Object o);&#125; 这样做的好处： 类的复杂性降低，实现的职责有清晰的定义 由复杂性降低导致可读性提高 由可读性提高导致可维护性提高 变更引起的风险降低，若做好单一职责，则一个接口修改只对相应的实现类影响，对其他接口不影响，提高系统扩展性和维护性 重要难处：单一职责最难划分的是职责，职责如何细化，这需要从实际的项目去考虑，若从功能上来说，定义一个IPhone接口是没有错的，实现了电话的功能。 本质： 其实 职责相当于导致变化的变化原因，单一职责原则提出了用职责/变化原因来衡量接口设计是否优良，但是职责和变化原因是不可度量的，因项目、环境而异。 里氏替换原则:LSP定义： 对于每个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，P的行为没有发生变化，则S类型是T类型的子类型。 所有引用基类的地方必须透明地适用其子类的对象 4层含义： 子类必须完全实现父类的方法(父类出现的地方，子类可以替代) 子类可以有自己的个性(子类出现的地方，父类可以替代) 覆盖或实现父类的方法时输入参数可以被放大(说白了子类方法重载父类方法的时候输入范围可以随便来) 1234567891011121314151617181920212223242526272829303132package com.study.LSP;import java.util.HashMap;import java.util.Map;/** * @Author: jerx * @Description: * @Date: Created in 12:07 2018/7/9 * @Modified By: */public class Client &#123; public static void main(String[] args) &#123; invokerF(); &#125; private static void invokerF() &#123; Father f = new Father(); HashMap map = new HashMap(); f.doSomething(map); &#125; //上面的方法，根据里氏替换原则，父类出现的地方子类可以完全替换 private static void invoker() &#123; Son f = new Son(); HashMap map = new HashMap(); f.doSomething(map); //由此可见，子类既可以重写父类的方法，又可以重载父类的方法以此扩大输入参数的范围 ， Map map1 = new HashMap(); f.doSomething(map1); &#125;&#125; 覆写或实现父类的方法时输出结果可以被缩小（说白了子类方法重写父类方法/子类方法重载父类方法的时候输出结果可以随便来） 重要实践要点在项目中若要采用里氏替换原则，尽量避免子类的”个性“： 一旦子类有个性，这个子类与父类关系难以调和，把子类作为父类使用，则抹杀了子类的个性 把子类单独作为一个业务来使用，则会让代码间的耦合关系混乱，缺乏类替换的标准 依赖倒置原则:DIP三层含义： 高层模块不应该依赖低层模块，两者都应该依赖其抽象； 抽象不应该依赖细节； 细节应该依赖抽象。 在java语言中的表现： 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过 接口或抽象类产生的； 接口或抽象类不依赖于实现类； 实现类依赖接口或抽象类。 依赖的三种写法：1.构造函数传递依赖对象接口类： 123456789101112package com.study.DIP;/** * @Author: jerx * @Description: * @Date: Created in 15:16 2018/7/9 * @Modified By: * 构造函数传递依赖对象 */public interface IDriver &#123; void drive();&#125; 实现类： 1234567891011121314151617181920212223package com.study.DIP.impl;import com.study.DIP.ICar;import com.study.DIP.IDriver;/** * @Author: jerx * @Description: * @Date: Created in 15:19 2018/7/9 * @Modified By: */public class DriverWiredFromConstructor implements IDriver &#123; private ICar car; public DriverWiredFromConstructor(ICar car) &#123; this.car = car; &#125; //由构造函数注入依赖对象Car public void drive() &#123; System.out.println("司机驾驶汽车:"); this.car.run(); &#125;&#125; 2.Setter方法传递依赖对象接口类： 123456789101112package com.study.DIP;/** * @Author: jerx * @Description: * @Date: Created in 15:23 2018/7/9 * @Modified By: */public interface IDriverSetter extends IDriver&#123; void setCar(ICar car);&#125; 实现类： 1234567891011121314151617181920212223package com.study.DIP.impl;import com.study.DIP.ICar;import com.study.DIP.IDriverSetter;/** * @Author: jerx * @Description: * @Date: Created in 15:21 2018/7/9 * @Modified By: */public class DriverWiredFromSetter implements IDriverSetter&#123; private ICar car; public void drive() &#123; System.out.println("司机驾驶汽车"); car.run(); &#125; //由setter方法传递依赖对象Car public void setCar(ICar car) &#123; this.car = car; &#125;&#125; 3.接口声明依赖对象接口类： 1234567891011package com.study.DIP;/** * @Author: jerx * @Description: * @Date: Created in 15:27 2018/7/9 * @Modified By: */public interface IDriverInterface &#123; void drive(ICar car);&#125; 实现类： 123456789101112131415161718package com.study.DIP.impl;import com.study.DIP.ICar;import com.study.DIP.IDriverInterface;/** * @Author: jerx * @Description: * @Date: Created in 15:27 2018/7/9 * @Modified By: */public class DriverWiredFromInterface implements IDriverInterface&#123; //由接口声明依赖对象Car public void drive(ICar car) &#123; System.out.println("司机驾驶汽车"); car.run(); &#125;&#125; 重要实践要点 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备 这是依赖倒置的基本要求，有了抽象才能倒置 变量的表面类型尽量是接口或者是抽象类 任何类都不应该从具体类派生 尽量不要覆写基类的方法 如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。 结合里氏替换原则使用 接口负责定义public属性和方法，并且声明与其他对象的依赖关系， 抽象类负责公共构造部分的实现， 实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。 重要什么是依赖倒置想知道什么是依赖倒置，应该先了解一下依赖正置是什么。 依赖正置说白了就是类间的依赖是实实在在的实现类间的依赖，这是面向实现编程 而编写程序需要抽象事物，抽象的结果是产生接口类和抽象类，而倒置则是指我们根据系统的设计而产生的抽象间的依赖，以代替人们传统思维中的事物间的依赖。 接口隔离原则定义建立单一接口，不要建立臃肿庞大的接口。 区别于单一职责原则接口隔离原则与单一职责的审视角度是不相同的， 单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分， 而接口隔离原则要求接口的方法尽量少 保证接口的纯洁性 尽量小尽量小，但是当根据接口单一原则要拆分接口时，必须先满足单一职责原则 高内聚不讲任何条件、立刻完成任务的行为就是高内聚的表现 高内聚要求在接口中尽量少公布public方法 定制服务​ 有限度 实践要点 一个接口只服务于一个子模块或业务逻辑 通过业务逻辑压缩接口中的public方法 已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理； 迪米特原则:LKP一个对象应该对其他对象有最少的了解。 4层含义1. 只和朋友交流出现在成员变量、方法的输入输出参数中的类称为成员朋友类； 而出现在方法体内部的类不属于朋友类 2. 朋友间也是有距离的尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。 3. 是自己的就是自己的经常出现的情况：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？你可以坚持这样一个原则：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 实践要点类间解耦，弱耦合， 未完待续。。。。 开闭原则一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 是什么为什么怎么实现]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java演进之门]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0%2Fnetty%2FJavaIO%E6%BC%94%E8%BF%9B%2F</url>
    <content type="text"><![CDATA[1.1 I/O基础入门Java1.4之前的早期版本，Java 对I/O的支持不完善，存在以下挑战和困难: 无缓冲加快速度：没有数据缓冲区，I/O性能存在问题； 无通道概念：没有C/C++中的Channel概念，只有输入和输出流； 阻塞时间长：同步阻塞式I/O通信(BIO)，通常会导致通信线程被长时间阻塞； 支持的字符集有限，硬件可移植性不好 1.1.1 Linux网络I/O模型简介Linux的内核 将所有外部设备看作一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个文件描述符(file descriptor, fd) 而对一个socket的读写也会有响应的描述符，称为]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Socket编程]]></title>
    <url>%2F2018%2F04%2F15%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0%2Fnetty%2FSocket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Socket编程Unix输入输出操作范本:Open—–&gt; Read—-&gt;Write—&gt;close Java 的 Socket 编程客户端编写123456789101112131415161718192021222324/*代码1.1 */public class ClientSocket &#123; public static void main(String args[]) &#123; //通信标识符：网络地址+端口 String host = "127.0.0.1"; int port = 8919; try &#123; //Open : 通过通信标识符 来创建socket对象 Socket client = new Socket(host, port); //Write : 1.通过socket对象得到OutputStream对象 Writer writer = new OutputStreamWriter(client.getOutputStream()); // 2.写入数据 writer.write("Hello From Client"); // 3.刷新(将缓冲区的数据发送出去) writer.flush(); //Close : 关闭 OutputStream和Socket writer.close(); client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 服务端编写Open—&gt;Read—&gt;Close 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*代码2.1*/package com.study.SocketPrograming;import java.io.IOException;import java.io.InputStreamReader;import java.io.Reader;import java.net.ServerSocket;import java.net.Socket;/** * @Author: jerx * @Description: * @Date: Created in 14:20 2018/4/15 * @Modified By: */public class Server &#123; public static void main(String[] args) &#123; int port = 8080; // 1.Open: 开启socket对象 ServerSocket server; try &#123; server = new ServerSocket(port); // 2.监听并 获取客户端的请求socket // accept是一个阻塞方法，在服务器与客户端之间建立联系之前一直阻塞 Socket socket = server.accept(); Reader reader = new InputStreamReader(socket.getInputStream()); char[] chars = new char[1024]; int len; // 3.Read: // 不断执行: // ①调用reader.read(char[])将1024个字符的数据copy进缓冲区中 // ②缓冲区中的数据再添加进StringBuilder对象 // 直到数据完全copy完毕 StringBuilder builder = new StringBuilder(); while ((len =reader.read(chars))!=-1)&#123; builder.append(new String(chars, 0, len)); &#125; System.out.println("Receive from client message=: " + builder); //4.Close reader.close(); socket.close(); server.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 1. Socket对象的创建基本需求：创建当前服务端开启的Socket监听端口 设置为8080，等待其他进程向我们这个端口发送信息 2.阻塞等待与客户端的连接 accept方法是阻塞方法，返回值是指向客户端socket对象的一个引用 阻塞于何处？ 可以打开accept源码查看一番 12345678910/*代码2.2*/public Socket accept() throws IOException &#123; if (isClosed()) throw new SocketException("Socket is closed"); if (!isBound()) throw new SocketException("Socket is not bound yet"); Socket s = new Socket((SocketImpl) null); implAccept(s); return s;&#125; implAccept方法 向implAccept方法传入一个SocketImpl为null的Socket，我们知道 Socket的实现都是Socket还是ServerSocket它们的工作都是通过SocketImpl类及其子类完成的，一个没有SocketImpl的Socket无法工作 那么我们继续看implAccept的方法 1234567891011121314151617181920212223242526272829303132333435/*代码2.3*/protected final void implAccept(Socket s) throws IOException &#123; SocketImpl si = null; try &#123; if (s.impl == null) //设置SocketImpl s.setImpl(); else &#123; s.impl.reset(); &#125; si = s.impl; s.impl = null; si.address = new InetAddress(); si.fd = new FileDescriptor(); getImpl().accept(si); SecurityManager security = System.getSecurityManager(); if (security != null) &#123; security.checkAccept(si.getInetAddress().getHostAddress(), si.getPort()); &#125; &#125; catch (IOException e) &#123; if (si != null) si.reset(); s.impl = si; throw e; &#125; catch (SecurityException e) &#123; if (si != null) si.reset(); s.impl = si; throw e; &#125; s.impl = si; s.postAccept(); &#125; 这里最重要的是getImpl.accept()方法的调用，在调用前，给Socket si创建了一个ServerSocketImpl， 但仍然没有指定该Socket的端口和网络地址，那么继续看getImpl().accept()方法。 getImpl.accept() 123456789101112131415/*代码2.4*/protected synchronized void accept(SocketImpl s) throws IOException &#123; if (s instanceof PlainSocketImpl) &#123; // pass in the real impl not the wrapper. //这里要将实际的Impl类传入accept方法，而不是包装类 SocketImpl delegate = ((PlainSocketImpl)s).impl; delegate.address = new InetAddress(); delegate.fd = new FileDescriptor(); impl.accept(delegate); // set fd to delegate's fd to be compatible with older releases s.fd = delegate.fd; &#125; else &#123; impl.accept(s); &#125; &#125; 判断是不是PlainSocketImpl，这个类在官方文档中介绍为 ，默认的sokcet实现类，源码中希望将一个真正的SocketImpl对象传入，而非其包装对象，可见PlainSocketImpl应该是一个SocketImpl的包装类。 所以我们将一个真正的SocketImpl对象传入impl.accept()方法中，且看impl.accept()方法 impl.accept() 1234567891011121314/*代码2.5*//** * Accepts connections. * @param s the connection */protected void accept(SocketImpl s) throws IOException &#123; //获取文件描述符, acquireFD(); try &#123; socketAccept(s); &#125; finally &#123; releaseFD(); &#125;&#125; 在这个方法中 为SocketImpl对象的 fduseCount加1 socketAccept(s); 12345678910111213141516171819202122232425262728293031/*代码2.6*/void socketAccept(SocketImpl s) throws IOException &#123; int nativefd = checkAndReturnNativeFD(); if (s == null) throw new NullPointerException("socket is null"); int newfd = -1; InetSocketAddress[] isaa = new InetSocketAddress[1]; if (timeout &lt;= 0) &#123; newfd = accept0(nativefd, isaa); &#125; else &#123; configureBlocking(nativefd, false); try &#123; waitForNewConnection(nativefd, timeout); newfd = accept0(nativefd, isaa); if (newfd != -1) &#123; configureBlocking(newfd, true); &#125; &#125; finally &#123; configureBlocking(nativefd, true); &#125; &#125; /* Update (SocketImpl)s' fd */ fdAccess.set(s.fd, newfd); /* Update socketImpls remote port, address and localport */ InetSocketAddress isa = isaa[0]; s.port = isa.getPort(); s.address = isa.getAddress(); s.localport = localport;&#125; 我们debug到 accept0()方法，发现是一个native方法，是一个非Java代码的接口，在native方法中阻塞等待得到新文件描述符以及通信标识符(网络地址+端口) 当我们启动一个Client时，accept0立刻返回新文件描述符，得到通信标识符 之后： 设置文件描述符，和网络地址及端口 回到上一层方法栈impl.accept， fdUseCount减1 回到上一层方法栈getImpl.accept()，设置文件描述符 回到上一层方法栈implAccept(),在应用有自己的安全管理器的情况下，检查接收的客户端连接的访问权限，而后将Socket的SocketImpl设置为含有该连接信息(文件描述符、通信标识符等)的SocketImpl，并将Socket的连接标志，创建标志，绑定标志设为true 回到上一层方法栈accept() 方法，接收连接后，将含有该连接信息的Socket返回 小结这里的阻塞等待 的 是关于客户端连接的信息(文件描述符，通信标识符等) 3.得到输入流，然后使用缓冲读取得到信息详解看代码2.1 4.关闭IO对象资源释放 文件描述符文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统]]></content>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F04%2F05%2FJVM%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略1.职能： 垃圾收集器的职能就是将堆中的”已死去“的对象进行回收。 那么在对堆进行回收前，必须先判断对象是否还活着 如果由于代码设计不合理可能会导致一些无用的对象仍然被判定为存活着而导致内存泄漏 2.对象死活 2.1.引用计数 优点：效率高，实现简单 缺点：很难解决对象之间相互循环引用的问题(这也是虚拟机不选用该算法来管理内存的原因) http://blog.csdn.net/u013613428/article/details/53763925 123456789101112131415161718192021222324252627282930313233/** * VM args : * -XX:+PrintGC 输出GC日志 * -XX:+PrintGCDetails 输出GC的详细日志 * -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） * -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） * -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 * -Xloggc:../logs/gc.log 日志文件的输出路径 * @Author: jerx * @Description: * @Date: Created in 15:08 2018/2/2 * @Modified By: */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB=1024*1024; private byte[] bigSize = new byte[2*_1MB]; public static void testGC()&#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; System.gc(); &#125; public static void main(String[] args) throws InterruptedException &#123; ReferenceCountingGC.testGC(); Thread.sleep(1000*10); &#125;&#125; 运行结果： 123 [GC 6718K-&gt;4848K(123392K), 0.0020877 secs][Full GC 4848K-&gt;4619K(123392K), 0.0112221 secs]Process finished with exit code 0 2.2.可达性分析 GC Roots : 虚拟机栈的本地变量表 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象从GC Roots出发向下搜索，所走过的路径：引用链当一个对象到GC Roots 没有任何引用链相连，即从GC Roots到该对象不可达，则为不可用对象，可回收。2.3.细分引用以上两种判断对象是否存活的算法都与引用有关。原来Java中对reference类型的定义：一个存储了一个代表另外一块内存地址的数值，在这样的定义下，一个对象只有被引用或者没有被引用的状态；实际上还需要描述一些特殊的对象：当内存空间足够时，能保留在内存中，而若内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。在jdk1.2之后，Java扩充了引用的概念：四种引用: 强引用 ：Object obj = new Object();软引用 ：SoftReference 在系统将要发生内存溢出异常去之前会把这些对象列进垃圾回收范围内弱引用 ：WeakReference 被弱引用关联的对象只能生存到下一次垃圾收集发生前，当垃圾收集器工作时，一定会回收掉只被弱引用关联的对象虚引用 : PhantomReference 对象不会因为弱引用的存在而对自身生存时间构成影响，设置虚引用的唯一目的是为了能在这个对象被收集器回收时收到一个系统通知 2.4.死前挣扎上面是解决了如何知道对象是否需要存活接下来来解决何时将对象回收 发现对象A没有与GC Roots相连接的引用链—&gt;第一次标记，并且进行一次筛选，筛选条件：是否需要执行finalize方法 有必要则将对象A放在F-Queue队列中，并在一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它， 执行指的是触发该方法的执行，但不会承诺等待它运行结束。 只触发finalize方法而不承诺等待它运行结束的原因：若对象A在finalize方法中执行缓慢/出现死循环，这会导致F-Queue队列其他对象永久等待，甚至整个系统崩溃。 怎么才算有必要执行？对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过 GC将对F-Queue中的对象进行第二次规模的标记，如果finalize方法中对象A成功拯救了自己(只需要重新与引用链的任何一个对象建立关联)，那么第二次标记时对象A将被移出”即将回收“的集合 分析：finalize方法运行代价高昂、不确定性大，不能保证各个对象的调用顺序，关闭外部资源之类的工作应该使用try-finally 2.5.回收方法区2.5.1.回收内容： 废弃常量 无用的类2.5.2.回收废弃常量条件： 没有任何String对象2.5.3.可能回收类的条件 实例已全部被回收 该类的加载器已被回收 该类对应的Class对象没有再任何地方被引用3.垃圾收集算法 3.1.标记-清除算法简述： 标记 标记所有需要回收的对象清除 直接清除标记过的对象 不足： 效率低 标记和清除 效率都不高 (怎么不高法？)空间碎片 标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致在程序运行过程中要分配较大对象时无法找到足够的连续内存而不得不触发又一次垃圾收集动作 3.2.复制算法简述： 划分为两块大小相等的两块，每次只用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存中，在回收时就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效 不足： 代价是将内存缩为原来一半 变形： 现在商用虚拟机包括HotSpot，会将内存分为一块Eden空间、两块较小的Survivor空间，HotSpot中Eden:fromSurvivor:toSurvivor=8:1:1分配担保：回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor，这块Survivor不够用时，依赖其他内存进行分配担保：即当这块Survivor没有足够空间存放上一次新生代收集下来的存活对象，则这些对象将直接通过分配担保进入老年代。 3.3.标记-整理算法此算法主要适用于老年代先标记然后将所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 3.4.分代收集算法新生代用复制算法老年代用标记-清除/标记-整理算法进行回收 4.算法实现4.1.枚举根节点 GC Roots准确式GC： 准确GC，准确的意思就是：虚拟机能确切知道哪些地方存放对象引用，从而加快GCRoots枚举的效率 执行系统停顿下来时，不需要一个不漏地检查完所有执行上下文和全局的引用位置 虚拟机有方法直接得知哪些地方存放着对象引用： HotSpot使用一组称为 OopMap 的数据结构达到这个目的，它将对象内什么偏移量上是什么类型的数据计算出来，在 JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。 eg:以下例子 call 指令有 OopMap 记录，指明 ebx 寄存器、栈中偏移量为 16 的内存区域中各有一个普通对象指针，有效范围从 call 指令开始直到 0x026eb730 (指令流的起始位置) + 14212345678910111213[Verified Entry Point]0x026eb730: mov %eax,-0x8000(%esp)…………;; ImplicitNullCheckStub slow case0x026eb7a9: call 0x026e83e0 ; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;;*caload; - java.lang.String::hashCode@48 (line 1489); &#123;runtime_call&#125;0x026eb7ae: push $0x83c5c18 ; &#123;external_word&#125;0x026eb7b3: call 0x026eb7b80x026eb7b8: pusha0x026eb7b9: call 0x0822bec0 ; &#123;runtime_call&#125;0x026eb7be: hlt 安全点为什么要有安全点的概念？ 因为 安全点 问题： 考虑如何让 GC发生时让所有线程都“跑”到最近的安全点上再停顿下来？两种方案： 抢先式中断(现在没有虚拟机使用这种方法) 先中断 再检查各个线程是否在安全点上，否则恢复线程，让其执行到安全点上 主动式中断 各线程执行到 在安全点时/在创建对象需要分配内存时 主动轮询 中断标志 中断标志为真时就自己中断挂起 ​ 安全区域 ​]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
