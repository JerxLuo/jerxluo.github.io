<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[垃圾收集器与内存分配策略]]></title>
    <url>%2F2018%2F04%2F05%2FJVM%2F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[垃圾收集器与内存分配策略1.职能： 垃圾收集器的职能就是将堆中的”已死去“的对象进行回收。 那么在对堆进行回收前，必须先判断对象是否还活着 如果由于代码设计不合理可能会导致一些无用的对象仍然被判定为存活着而导致内存泄漏 2.对象死活 2.1.引用计数 优点：效率高，实现简单 缺点：很难解决对象之间相互循环引用的问题(这也是虚拟机不选用该算法来管理内存的原因) http://blog.csdn.net/u013613428/article/details/53763925 123456789101112131415161718192021222324252627282930313233/** * VM args : * -XX:+PrintGC 输出GC日志 * -XX:+PrintGCDetails 输出GC的详细日志 * -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） * -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） * -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 * -Xloggc:../logs/gc.log 日志文件的输出路径 * @Author: jerx * @Description: * @Date: Created in 15:08 2018/2/2 * @Modified By: */public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB=1024*1024; private byte[] bigSize = new byte[2*_1MB]; public static void testGC()&#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; System.gc(); &#125; public static void main(String[] args) throws InterruptedException &#123; ReferenceCountingGC.testGC(); Thread.sleep(1000*10); &#125;&#125; 运行结果： 123 [GC 6718K-&gt;4848K(123392K), 0.0020877 secs][Full GC 4848K-&gt;4619K(123392K), 0.0112221 secs]Process finished with exit code 0 2.2.可达性分析 GC Roots : 虚拟机栈的本地变量表 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI（Native方法）引用的对象从GC Roots出发向下搜索，所走过的路径：引用链当一个对象到GC Roots 没有任何引用链相连，即从GC Roots到该对象不可达，则为不可用对象，可回收。2.3.细分引用以上两种判断对象是否存活的算法都与引用有关。原来Java中对reference类型的定义：一个存储了一个代表另外一块内存地址的数值，在这样的定义下，一个对象只有被引用或者没有被引用的状态；实际上还需要描述一些特殊的对象：当内存空间足够时，能保留在内存中，而若内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。在jdk1.2之后，Java扩充了引用的概念：四种引用: 强引用 ：Object obj = new Object();软引用 ：SoftReference 在系统将要发生内存溢出异常去之前会把这些对象列进垃圾回收范围内弱引用 ：WeakReference 被弱引用关联的对象只能生存到下一次垃圾收集发生前，当垃圾收集器工作时，一定会回收掉只被弱引用关联的对象虚引用 : PhantomReference 对象不会因为弱引用的存在而对自身生存时间构成影响，设置虚引用的唯一目的是为了能在这个对象被收集器回收时收到一个系统通知 2.4.死前挣扎上面是解决了如何知道对象是否需要存活接下来来解决何时将对象回收 发现对象A没有与GC Roots相连接的引用链—&gt;第一次标记，并且进行一次筛选，筛选条件：是否需要执行finalize方法 有必要则将对象A放在F-Queue队列中，并在一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它， 执行指的是触发该方法的执行，但不会承诺等待它运行结束。 只触发finalize方法而不承诺等待它运行结束的原因：若对象A在finalize方法中执行缓慢/出现死循环，这会导致F-Queue队列其他对象永久等待，甚至整个系统崩溃。 怎么才算有必要执行？对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过 GC将对F-Queue中的对象进行第二次规模的标记，如果finalize方法中对象A成功拯救了自己(只需要重新与引用链的任何一个对象建立关联)，那么第二次标记时对象A将被移出”即将回收“的集合 分析：finalize方法运行代价高昂、不确定性大，不能保证各个对象的调用顺序，关闭外部资源之类的工作应该使用try-finally 2.5.回收方法区2.5.1.回收内容： 废弃常量 无用的类2.5.2.回收废弃常量条件： 没有任何String对象2.5.3.可能回收类的条件 实例已全部被回收 该类的加载器已被回收 该类对应的Class对象没有再任何地方被引用3.垃圾收集算法 3.1.标记-清除算法简述： 标记 标记所有需要回收的对象清除 直接清除标记过的对象 不足： 效率低 标记和清除 效率都不高 (怎么不高法？)空间碎片 标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致在程序运行过程中要分配较大对象时无法找到足够的连续内存而不得不触发又一次垃圾收集动作 3.2.复制算法简述： 划分为两块大小相等的两块，每次只用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块内存中，在回收时就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效 不足： 代价是将内存缩为原来一半 变形： 现在商用虚拟机包括HotSpot，会将内存分为一块Eden空间、两块较小的Survivor空间，HotSpot中Eden:fromSurvivor:toSurvivor=8:1:1分配担保：回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor，这块Survivor不够用时，依赖其他内存进行分配担保：即当这块Survivor没有足够空间存放上一次新生代收集下来的存活对象，则这些对象将直接通过分配担保进入老年代。 3.3.标记-整理算法此算法主要适用于老年代先标记然后将所有存活对象都向一端移动，然后直接清理掉端边界以外的内存 3.4.分代收集算法新生代用复制算法老年代用标记-清除/标记-整理算法进行回收 4.算法实现4.1.枚举根节点 GC Roots准确式GC： 执行系统停顿下来时，不需要一个不漏地检查完所有执行上下文和全局的引用位置 虚拟机有方法直接得知哪些地方存放着对象引用： HotSpot使用一组称为 OopMap 的数据结构达到这个目的，它将对象内什么偏移量上是什么类型的数据计算出来，在 JIT编译过程中，也会在特定位置记录下栈和寄存器中哪些位置是引用。 eg:以下例子 call 指令有 OopMap 记录，指明 ebx 寄存器、栈中偏移量为 16 的内存区域中各有一个普通对象指针，有效范围从 call 指令开始直到 0x026eb730 (指令流的起始位置) + 14212345678910111213[Verified Entry Point]0x026eb730: mov %eax,-0x8000(%esp)…………;; ImplicitNullCheckStub slow case0x026eb7a9: call 0x026e83e0 ; OopMap&#123;ebx=Oop [16]=Oop off=142&#125;;*caload; - java.lang.String::hashCode@48 (line 1489); &#123;runtime_call&#125;0x026eb7ae: push $0x83c5c18 ; &#123;external_word&#125;0x026eb7b3: call 0x026eb7b80x026eb7b8: pusha0x026eb7b9: call 0x0822bec0 ; &#123;runtime_call&#125;0x026eb7be: hlt 安全点安全点解决的问题：在OopMap的协助下，HotSpot可以快速且准确的完成OopMap ：记录特定范围内引用类型的位置记录 OopMap 的位置 称为安全点(Safepoint)问题： 考虑如何让 GC发生时让所有线程都“跑”到最近的安全点上再停顿下来？两种方案： 抢先式中断(现在没有虚拟机使用这种方法) 先中断 再检查各个线程是否在安全点上，否则恢复线程，让其执行到安全点上 主动式中断 各线程执行到 在安全点时/在创建对象需要分配内存时 主动轮询 中断标志 中断标志为真时就自己中断挂起 ​ 安全区域 ​]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
</search>
